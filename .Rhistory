curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
gsea$condenseParent <- parent
return(gsea)
}
gsea <- gseaCondenser::myGsea
gsea <- condenseGsea(gsea, similarity=0.3)
View(gsea)
parents <- apply(gsea,1,function(x) as.numeric(unlist(strsplit(x[which(colnames(gsea) %in% "condenseParents")], split=","))))
parents <- apply(gsea,1,function(x) as.numeric(unlist(strsplit(x[which(colnames(gsea) %in% "condenseParents")], split=","))))
View(parents)
as.numeric(unlist(strsplit(gsea[1,][which(colnames(gsea) %in% "condenseParents")], split=",")))
as.numeric(unlist(strsplit(gsea[1,][which(colnames(gsea) %in% "condenseParents")], split=",")))
gsea[1,]
gsea[1,"cendenseParent"]
gsea[1,"condenseParent"]
apply(gsea,1, function(x) x[2])
apply(gsea,1, function(x) x["condenseParents"])
unlist(apply(gsea,1, function(x) x["condenseParents"]))
strsplit(unlist(apply(gsea,1, function(x) x["condenseParents"])), split=",")
parents <- apply(gsea,1,function(x) as.numeric(strsplit(unlist(x["condenseParents"]), split=",")))
parents <- apply(gsea,1,function(x) unlist(x["condenseParents"], split=","))
parents <- apply(gsea,1,function(x) unlist(x["condenseParents"]))
parents
parents <- as.numeric(strsplit(apply(gsea,1,function(x) unlist(x["condenseParents"])))
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
gsea$condenseParent <- parent
return(gsea)
}
parents <- as.numeric(strsplit(apply(gsea,1,function(x) unlist(x["condenseParents"]))))
parents <- as.numeric(strsplit(apply(gsea,1,function(x) unlist(x["condenseParents"])), split=","))
parents <- (strsplit(apply(gsea,1,function(x) unlist(x["condenseParents"])), split=","))
parents
parents <- lapply(parents, as.numeric)
parents
parents <- strsplit(apply(gsea,1,function(x) unlist(x["condenseParents"])), split=",")
parents <- lapply(parents, as.numeric)
parents
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
colname="hit_genes"
sep=","
similarity=0.9
gsea$condenseID <- seq(nrow(gsea))
gsea$condenseChildren <- ""
gsea$condenseParents <- ""
genes <- strsplit(gsea[,colname], split=sep)
#ratiomat will become matrix where each row is a set and each column is a set. The cells will contain the percentage of overlap between the sets.
ratiomat <- sapply(genes, function(x) sapply(genes, function(y) length(intersect(x,y)) )) #first, the cells contain absolute numbers
ratiomat <- as.data.frame(ratiomat)
rownames(ratiomat) <- NULL
genes <- strsplit(gsea[,colname], split=sep)
View(gsea)
colname="genes"
genes <- strsplit(gsea[,colname], split=sep)
#ratiomat will become matrix where each row is a set and each column is a set. The cells will contain the percentage of overlap between the sets.
ratiomat <- sapply(genes, function(x) sapply(genes, function(y) length(intersect(x,y)) )) #first, the cells contain absolute numbers
ratiomat <- as.data.frame(ratiomat)
rownames(ratiomat) <- NULL
colnames(ratiomat) <- seq(nrow(gsea))
ratiomat <- apply(ratiomat, 2, function(x) x/max(x)) #ratio is intersect of the sets vs. set size (of the column set)
#each time a similarity value reaches the threshold, the smaller set's ID is added to "eaten" and to the "condenseChildren" column of the bigger set
eaten <- NA
for(i in seq(nrow(ratiomat))) { #the ratio is intersect/n (number of genes of the column set), So j
for(j in seq(ncol(ratiomat))){
#if the ratio of intersect and set size (of set j) is bigger than the ratio of intersect and set size (of set i), it means that set j is smaller. Thus, it will get eaten
if(ratiomat[i,j]>similarity & ratiomat[i,j] > ratiomat[j,i]){ #by using >, sets do not eat themselves, and it is always the smaller set that gets eaten
gsea$condenseChildren[i] <- paste0(gsea$condenseChildren[i],",",j) #the set that does not get eaten gets the ID of j for its Children column
gsea$condenseParents[j] <- paste0(gsea$condenseParents[j],",",i) # the set that does get eaten gets the ID of i for its Parent column
eaten <- c(eaten,j) # just a vector, gathering all IDs from sets that were eaten
}
}
}
gsea$condenseSurvive <- ifelse(gsea$condenseID %in% eaten, FALSE, TRUE)
gsea$condenseChildren <- gsub("^,","",gsea$condenseChildren)
gsea$condenseParents <- gsub("^,","",gsea$condenseParents)
parents <- strsplit(apply(gsea,1,function(x) unlist(x["condenseParents"])), split=",")
parents
parents <- lapply(parents, as.numeric)
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
parent
parents
similarity=0.3
gsea$condenseID <- seq(nrow(gsea))
gsea$condenseChildren <- ""
gsea$condenseParents <- ""
genes <- strsplit(gsea[,colname], split=sep)
#ratiomat will become matrix where each row is a set and each column is a set. The cells will contain the percentage of overlap between the sets.
ratiomat <- sapply(genes, function(x) sapply(genes, function(y) length(intersect(x,y)) )) #first, the cells contain absolute numbers
ratiomat <- as.data.frame(ratiomat)
rownames(ratiomat) <- NULL
colnames(ratiomat) <- seq(nrow(gsea))
ratiomat <- apply(ratiomat, 2, function(x) x/max(x)) #ratio is intersect of the sets vs. set size (of the column set)
#each time a similarity value reaches the threshold, the smaller set's ID is added to "eaten" and to the "condenseChildren" column of the bigger set
eaten <- NA
for(i in seq(nrow(ratiomat))) { #the ratio is intersect/n (number of genes of the column set), So j
for(j in seq(ncol(ratiomat))){
#if the ratio of intersect and set size (of set j) is bigger than the ratio of intersect and set size (of set i), it means that set j is smaller. Thus, it will get eaten
if(ratiomat[i,j]>similarity & ratiomat[i,j] > ratiomat[j,i]){ #by using >, sets do not eat themselves, and it is always the smaller set that gets eaten
gsea$condenseChildren[i] <- paste0(gsea$condenseChildren[i],",",j) #the set that does not get eaten gets the ID of j for its Children column
gsea$condenseParents[j] <- paste0(gsea$condenseParents[j],",",i) # the set that does get eaten gets the ID of i for its Parent column
eaten <- c(eaten,j) # just a vector, gathering all IDs from sets that were eaten
}
}
}
gsea$condenseSurvive <- ifelse(gsea$condenseID %in% eaten, FALSE, TRUE)
gsea$condenseChildren <- gsub("^,","",gsea$condenseChildren)
gsea$condenseParents <- gsub("^,","",gsea$condenseParents)
parents <- strsplit(apply(gsea,1,function(x) unlist(x["condenseParents"])), split=",")
parents <- lapply(parents, as.numeric)
parents
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
parent
parents
parent
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
# overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
# parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
parent
parents
j=5
curparents <- parents[[j]]
curparents
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
overlaps
ratiomat[1,2]
ratiomat[2]
ratiomat
parents
overlaps
ratiomat[1,1]
ratiomat <- as.data.frame(ratiomat)
ratiomat[1,1]
#each time a similarity value reaches the threshold, the smaller set's ID is added to "eaten" and to the "condenseChildren" column of the bigger set
eaten <- NA
for(i in seq(nrow(ratiomat))) { #the ratio is intersect/n (number of genes of the column set), So j
for(j in seq(ncol(ratiomat))){
#if the ratio of intersect and set size (of set j) is bigger than the ratio of intersect and set size (of set i), it means that set j is smaller. Thus, it will get eaten
if(ratiomat[i,j]>similarity & ratiomat[i,j] > ratiomat[j,i]){ #by using >, sets do not eat themselves, and it is always the smaller set that gets eaten
gsea$condenseChildren[i] <- paste0(gsea$condenseChildren[i],",",j) #the set that does not get eaten gets the ID of j for its Children column
gsea$condenseParents[j] <- paste0(gsea$condenseParents[j],",",i) # the set that does get eaten gets the ID of i for its Parent column
eaten <- c(eaten,j) # just a vector, gathering all IDs from sets that were eaten
}
}
}
gsea$condenseSurvive <- ifelse(gsea$condenseID %in% eaten, FALSE, TRUE)
gsea$condenseChildren <- gsub("^,","",gsea$condenseChildren)
gsea$condenseParents <- gsub("^,","",gsea$condenseParents)
parents <- strsplit(apply(gsea,1,function(x) unlist(x["condenseParents"])), split=",")
parents <- lapply(parents, as.numeric)
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
# parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
parents
gsea$condenseParents
for(i in seq(nrow(ratiomat))) { #the ratio is intersect/n (number of genes of the column set), So j
for(j in seq(ncol(ratiomat))){
#if the ratio of intersect and set size (of set j) is bigger than the ratio of intersect and set size (of set i), it means that set j is smaller. Thus, it will get eaten
if(ratiomat[i,j]>similarity & ratiomat[i,j] > ratiomat[j,i]){ #by using >, sets do not eat themselves, and it is always the smaller set that gets eaten
gsea$condenseChildren[i] <- paste0(gsea$condenseChildren[i],",",j) #the set that does not get eaten gets the ID of j for its Children column
gsea$condenseParents[j] <- paste0(gsea$condenseParents[j],",",i) # the set that does get eaten gets the ID of i for its Parent column
eaten <- c(eaten,j) # just a vector, gathering all IDs from sets that were eaten
}
}
}
eaten <- NA
gsea$condenseChildren <- ""
gsea$condenseParents <- ""
for(i in seq(nrow(ratiomat))) { #the ratio is intersect/n (number of genes of the column set), So j
for(j in seq(ncol(ratiomat))){
#if the ratio of intersect and set size (of set j) is bigger than the ratio of intersect and set size (of set i), it means that set j is smaller. Thus, it will get eaten
if(ratiomat[i,j]>similarity & ratiomat[i,j] > ratiomat[j,i]){ #by using >, sets do not eat themselves, and it is always the smaller set that gets eaten
gsea$condenseChildren[i] <- paste0(gsea$condenseChildren[i],",",j) #the set that does not get eaten gets the ID of j for its Children column
gsea$condenseParents[j] <- paste0(gsea$condenseParents[j],",",i) # the set that does get eaten gets the ID of i for its Parent column
eaten <- c(eaten,j) # just a vector, gathering all IDs from sets that were eaten
}
}
}
eaten
gsea
gsea$condenseSurvive <- ifelse(gsea$condenseID %in% eaten, FALSE, TRUE)
gsea$condenseChildren <- gsub("^,","",gsea$condenseChildren)
gsea$condenseParents <- gsub("^,","",gsea$condenseParents)
gsea
gsea$condenseParents
parents <- strsplit(apply(gsea,1,function(x) gsea$condenseParents), split=",")
parents
apply(gsea,1,function(x) gsea$condenseParents)
sapply(gsea, function(x) gsea$condenseParents)
gsea$condenseParents
sapply(gsea, function(x) gsea$condenseParents)
sapply(gsea$condenseParents, function(x) x),
sapply(gsea$condenseParents, function(x) x)
gsea$condenseParents
sapply(gsea$condenseParents, function(x) x)
strsplit(sapply(gsea$condenseParents, function(x) x), split=",")
parents <- lapply(parents, as.numeric)
parents
parents <- strsplit(sapply(gsea$condenseParents, function(x) x), split=",")
parents
lapply(parents, as.numeric)
parents <- lapply(parents, as.numeric)
parents
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
# parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
curparents <- parents[[j]]
curparents
j=5
curparents <- parents[[j]]
curparents
overlaps <-  ratiomat[ curparents , rep(j,length(curparents)) ] #extract overlap values for all parents (normalized by the set size of the child)
overlaps
ratiomat[1,1]
ratiomat[c(1,2),1]
ratiomat[c(1,2),c(1,4)]
overlaps <- sapply(curparents, function(j) ratiomat[j,i]) #extract overlap values for all parents (normalized by the set size of the child)
overlaps
j
parents
j
curparents
ratiomat[5,1]
ratiomat[5,4]
overlaps <- sapply(curparents, function(i) ratiomat[j,i]) #extract overlap values for all parents (normalized by the set size of the child)
overlaps
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
parent
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
overlaps2
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
parent
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <- sapply(curparents, function(i) ratiomat[j,i]) #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
parent
gsea$condenseParent <- unlist(parent)
gsea
#' @param sep charachter. What genes in the column string? E.g. if a cell of the column would look like "HOXA9,HOXA3", you need to set sep=","
#' @param similarity number, what has to be the minimum gene overlap between two terms in order for one to be regarded as redundant?
#' @return data.frame similar to the input, but with 3 added columns: condenseID has a simple numeric ID for each row. condenseChildren lists the IDs of all sets that were eaten by this set. condenseDropout states whether or not this set was eaten itself.
#' @export
#' @examples
#' library(gseaCondenser)
#'
#' gsea <- gseaCondenser::myGsea
#' gsea <- condenseGsea(gsea, similarity=0.3)
#' head(gsea)
condenseGsea <- function(gsea, colname="genes", sep=",", similarity=0.9){
gsea$condenseID <- seq(nrow(gsea))
genes <- strsplit(gsea[,colname], split=sep)
#ratiomat will become matrix where each row is a set and each column is a set. The cells will contain the percentage of overlap between the sets.
ratiomat <- sapply(genes, function(x) sapply(genes, function(y) length(intersect(x,y)) )) #first, the cells contain absolute numbers
ratiomat <- as.data.frame(ratiomat)
rownames(ratiomat) <- NULL
colnames(ratiomat) <- seq(nrow(gsea))
ratiomat <- apply(ratiomat, 2, function(x) x/max(x)) #ratio is intersect of the sets vs. set size (of the column set)
ratiomat <- as.data.frame(ratiomat)
#each time a similarity value reaches the threshold, the smaller set's ID is added to "eaten" and to the "condenseChildren" column of the bigger set
eaten <- NA
gsea$condenseChildren <- ""
gsea$condenseParents <- ""
for(i in seq(nrow(ratiomat))) { #the ratio is intersect/n (number of genes of the column set), So j
for(j in seq(ncol(ratiomat))){
#if the ratio of intersect and set size (of set j) is bigger than the ratio of intersect and set size (of set i), it means that set j is smaller. Thus, it will get eaten
if(ratiomat[i,j]>similarity & ratiomat[i,j] > ratiomat[j,i]){ #by using >, sets do not eat themselves, and it is always the smaller set that gets eaten
gsea$condenseChildren[i] <- paste0(gsea$condenseChildren[i],",",j) #the set that does not get eaten gets the ID of j for its Children column
gsea$condenseParents[j] <- paste0(gsea$condenseParents[j],",",i) # the set that does get eaten gets the ID of i for its Parent column
eaten <- c(eaten,j) # just a vector, gathering all IDs from sets that were eaten
}
}
}
gsea$condenseSurvive <- ifelse(gsea$condenseID %in% eaten, FALSE, TRUE)
gsea$condenseChildren <- gsub("^,","",gsea$condenseChildren)
gsea$condenseParents <- gsub("^,","",gsea$condenseParents)
parents <- strsplit(sapply(gsea$condenseParents, function(x) x), split=",")
parents <- lapply(parents, as.numeric)
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <- sapply(curparents, function(i) ratiomat[j,i]) #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
gsea$condenseParentID <- unlist(parent)
gsea$condenseParentName <- gseapathway[gsea$condenseParentID]
return(gsea)
}
gsea <- gseaCondenser::myGsea
gsea <- condenseGsea(gsea, similarity=0.3)
#' @param sep charachter. What genes in the column string? E.g. if a cell of the column would look like "HOXA9,HOXA3", you need to set sep=","
#' @param similarity number, what has to be the minimum gene overlap between two terms in order for one to be regarded as redundant?
#' @return data.frame similar to the input, but with 3 added columns: condenseID has a simple numeric ID for each row. condenseChildren lists the IDs of all sets that were eaten by this set. condenseDropout states whether or not this set was eaten itself.
#' @export
#' @examples
#' library(gseaCondenser)
#'
#' gsea <- gseaCondenser::myGsea
#' gsea <- condenseGsea(gsea, similarity=0.3)
#' head(gsea)
condenseGsea <- function(gsea, colname="genes", sep=",", similarity=0.9){
gsea$condenseID <- seq(nrow(gsea))
genes <- strsplit(gsea[,colname], split=sep)
#ratiomat will become matrix where each row is a set and each column is a set. The cells will contain the percentage of overlap between the sets.
ratiomat <- sapply(genes, function(x) sapply(genes, function(y) length(intersect(x,y)) )) #first, the cells contain absolute numbers
ratiomat <- as.data.frame(ratiomat)
rownames(ratiomat) <- NULL
colnames(ratiomat) <- seq(nrow(gsea))
ratiomat <- apply(ratiomat, 2, function(x) x/max(x)) #ratio is intersect of the sets vs. set size (of the column set)
ratiomat <- as.data.frame(ratiomat)
#each time a similarity value reaches the threshold, the smaller set's ID is added to "eaten" and to the "condenseChildren" column of the bigger set
eaten <- NA
gsea$condenseChildren <- ""
gsea$condenseParents <- ""
for(i in seq(nrow(ratiomat))) { #the ratio is intersect/n (number of genes of the column set), So j
for(j in seq(ncol(ratiomat))){
#if the ratio of intersect and set size (of set j) is bigger than the ratio of intersect and set size (of set i), it means that set j is smaller. Thus, it will get eaten
if(ratiomat[i,j]>similarity & ratiomat[i,j] > ratiomat[j,i]){ #by using >, sets do not eat themselves, and it is always the smaller set that gets eaten
gsea$condenseChildren[i] <- paste0(gsea$condenseChildren[i],",",j) #the set that does not get eaten gets the ID of j for its Children column
gsea$condenseParents[j] <- paste0(gsea$condenseParents[j],",",i) # the set that does get eaten gets the ID of i for its Parent column
eaten <- c(eaten,j) # just a vector, gathering all IDs from sets that were eaten
}
}
}
gsea$condenseSurvive <- ifelse(gsea$condenseID %in% eaten, FALSE, TRUE)
gsea$condenseChildren <- gsub("^,","",gsea$condenseChildren)
gsea$condenseParents <- gsub("^,","",gsea$condenseParents)
parents <- strsplit(sapply(gsea$condenseParents, function(x) x), split=",")
parents <- lapply(parents, as.numeric)
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <- sapply(curparents, function(i) ratiomat[j,i]) #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
gsea$condenseParentID <- unlist(parent)
gsea$condenseParentName <- gsea$pathway[gsea$condenseParentID]
return(gsea)
}
gsea <- condenseGsea(gsea, similarity=0.3)
head(gsea)
gsea <- gseaCondenser::myGsea
gsea <- condenseGsea(gsea, similarity=0.3)
head(gsea)
gsea <- gseaCondenser::myGsea
gsea <- condenseGsea(gsea, similarity=0.1)
head(gsea)
#' @param sep charachter. What genes in the column string? E.g. if a cell of the column would look like "HOXA9,HOXA3", you need to set sep=","
#' @param similarity number, what has to be the minimum gene overlap between two terms in order for one to be regarded as redundant?
#' @return data.frame similar to the input, but with 3 added columns: condenseID has a simple numeric ID for each row. condenseChildren lists the IDs of all sets that were eaten by this set. condenseDropout states whether or not this set was eaten itself.
#' @export
#' @examples
#' library(gseaCondenser)
#'
#' gsea <- gseaCondenser::myGsea
#' gsea <- condenseGsea(gsea, similarity=0.3)
#' head(gsea)
condenseGsea <- function(gsea, colname="genes", sep=",", similarity=0.9){
gsea$condenseID <- seq(nrow(gsea))
genes <- strsplit(gsea[,colname], split=sep)
#ratiomat will become matrix where each row is a set and each column is a set. The cells will contain the percentage of overlap between the sets.
ratiomat <- sapply(genes, function(x) sapply(genes, function(y) length(intersect(x,y)) )) #first, the cells contain absolute numbers
ratiomat <- as.data.frame(ratiomat)
rownames(ratiomat) <- NULL
colnames(ratiomat) <- seq(nrow(gsea))
ratiomat <- apply(ratiomat, 2, function(x) x/max(x)) #ratio is intersect of the sets vs. set size (of the column set)
ratiomat <- as.data.frame(ratiomat)
#each time a similarity value reaches the threshold, the smaller set's ID is added to "eaten" and to the "condenseChildren" column of the bigger set
eaten <- NA
gsea$condenseChildren <- ""
gsea$condenseParents <- ""
for(i in seq(nrow(ratiomat))) { #the ratio is intersect/n (number of genes of the column set), So j
for(j in seq(ncol(ratiomat))){
#if the ratio of intersect and set size (of set j) is bigger than the ratio of intersect and set size (of set i), it means that set j is smaller. Thus, it will get eaten
if(ratiomat[i,j]>similarity & ratiomat[i,j] > ratiomat[j,i]){ #by using >, sets do not eat themselves, and it is always the smaller set that gets eaten
gsea$condenseChildren[i] <- paste0(gsea$condenseChildren[i],",",j) #the set that does not get eaten gets the ID of j for its Children column
gsea$condenseParents[j] <- paste0(gsea$condenseParents[j],",",i) # the set that does get eaten gets the ID of i for its Parent column
eaten <- c(eaten,j) # just a vector, gathering all IDs from sets that were eaten
}
}
}
gsea$condenseChildren <- gsub("^,","",gsea$condenseChildren)
gsea$condenseParents <- gsub("^,","",gsea$condenseParents)
parents <- strsplit(sapply(gsea$condenseParents, function(x) x), split=",")
parents <- lapply(parents, as.numeric)
#the best parent will be determined by which parent shares the most genes with the child
parent <- lapply(seq_along(parents), function(j) {
curparents <- parents[[j]]
if(length(curparents)==0){NA}else{ #for each row in gsea, extract the parents (j is the child)
overlaps <- sapply(curparents, function(i) ratiomat[j,i]) #extract overlap values for all parents (normalized by the set size of the child)
parent <- curparents[which(overlaps==max(overlaps))] #choose the parent with the highest overlap value. This could lead to several parents
overlaps2 <- ratiomat[ rep(j,length(parent)) , parent ] #extract overlap values for all parents (normalized by the set size of the parent)
parent <- ifelse(length(parent)==1, parent, parent[which(overlaps2==max(overlaps2))][1] ) #choose the parent with the highest overlap value. Still, this could leave several parents, which is why we just pick the first one
return(parent)
}
})
parent <- ifelse(is.na(parent), gsea$condenseID, parent)
gsea$condenseParentID <- unlist(parent)
gsea$condenseParentName <- gsea$pathway[gsea$condenseParentID]
gsea$condenseSurvive <- ifelse(gsea$condenseID %in% eaten, FALSE, TRUE)
return(gsea)
}
gsea <- gseaCondenser::myGsea
gsea <- condenseGsea(gsea, similarity=0.1)
head(gsea)
ggplot(gsea, aes(NES, pval)) + geom_point()
library(ggplot2)
ggplot(gsea, aes(NES, pval)) + geom_point()
ggplot(gsea, aes(NES, pval, color=condenseParentName)) + geom_point()
ggplot(subset(gsea, condenseSurvive), aes(NES, pval, color=condenseParentName)) + geom_point()
ggplot(subset(gsea, condenseSurvive), aes(GO_ID, NES, color=condenseParentName)) + geom_point()
ggplot(subset(gsea, condenseSurvive), aes(pathway, NES, color=condenseParentName)) + geom_point()
ggplot(subset(gsea, condenseSurvive), aes(NES, pathway, color=condenseParentName)) + geom_point()
ggplot(subset(gsea, !condenseSurvive), aes(NES, pathway, color=condenseParentName)) + geom_point()
library(gseaCondenser)
devtools::document()
library(gseaCondenser)
devtools::document()
devtools::document()
library(gseaCondenser)
gsea <- gseaCondenser::myGsea
gsea <- condenseGsea(gsea, similarity=0.3)
View(gsea)
library(gseaCondenser)
devtools::document()
